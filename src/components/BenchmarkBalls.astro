---
// BenchmarkBalls.astro
// Drop into: src/components/BenchmarkBalls.astro
// Usage: <BenchmarkBalls /> or <BenchmarkBalls items={[...]} />

type Item = {
  label: string;
  // Higher = faster (shorter duration). You can think of it as "ops/sec".
  speed: number;
  // Optional: CSS color for the ball.
  color?: string;
};

const {
  items = [
    { label: "Rust", speed: 420, color: "#F97316" },
    { label: "Go", speed: 300, color: "#06B6D4" },
    { label: "JS", speed: 240, color: "#FACC15" },
    { label: "Python", speed: 80, color: "#60A5FA" },
  ] satisfies Item[],
  // Visual controls
  rowHeight = 69,          // px
  rowGap = 15,              // px
  ballSize = 35,           // px
  labelWidth = 92,         // px
  // Motion controls
  raceDuration = 3,      // seconds for the fastest one-way leg
  stagger = 0,             // seconds delay per row
  infinite = true,        // keep balls moving continuously
  sourceLabel = "based on node.js ipc graph (50 msg avg)",
} = Astro.props as {
  items?: Item[];
  rowHeight?: number;
  rowGap?: number;
  ballSize?: number;
  labelWidth?: number;
  raceDuration?: number;
  stagger?: number;
  infinite?: boolean;
  sourceLabel?: string;
};

const speeds = items.map((d) => d.speed);
const maxSpeed = Math.max(...speeds, 1);
const speedFormatter = new Intl.NumberFormat("en-US");

// Fastest ball reaches the end in raceDuration seconds.
// Others scale proportionally by speed ratio.
function durationFor(speed: number) {
  const safeSpeed = Math.max(0.0001, speed);
  return raceDuration * (maxSpeed / safeSpeed);
}

function speedText(speed: number) {
  return `${speedFormatter.format(speed)} req/sec`;
}

function speedAriaText(speed: number) {
  const noun = Math.abs(speed) === 1 ? "request" : "requests";
  return `${speedFormatter.format(speed)} ${noun} per second`;
}

function barWidthPercent(speed: number) {
  const ratio = Math.max(0, speed) / maxSpeed;
  return Math.max(8, ratio * 100);
}
---

<section
  class="bench not-content"
  data-benchmark-balls
  data-bench-infinite={infinite ? "1" : "0"}
  style={`
    --row-h:${rowHeight}px;
    --row-gap:${rowGap}px;
    --ball:${ballSize}px;
    --label-w:${labelWidth}px;
    --stagger:${stagger}s;
    --race-window:${raceDuration}s;
    --iter:${infinite ? "infinite" : "1"};
  `}
  aria-label="Benchmark balls animation"
>
  <!-- <div class="legend" aria-hidden="true">
    <span class="pill">left → right → left</span>
    <span class="pill">fastest: {fastestLegDuration}s each way</span>
    <span class="pill">Astro-ready</span>
  </div> -->

  <div class="rows" role="list">
    {items.map((it, i) => (
      <div
        class="row"
        role="listitem"
        style={`
          --dur:${durationFor(it.speed)}s;
          --delay:${(i * stagger).toFixed(3)}s;
          --c:${it.color ?? "currentColor"};
          --bar-w:${barWidthPercent(it.speed).toFixed(2)}%;
        `}
        aria-label={`${it.label}, speed ${speedAriaText(it.speed)}`}
      >
        <div class="label" title={it.label}>
          {it.label}
        </div>

        <div class="track" data-track>
          <div class="bar" aria-hidden="true"></div>
          <div class="ball" aria-hidden="true"></div>
        </div>

        <div class="meta" aria-hidden="true">
          <span class="speed">{speedText(it.speed)}</span>
        </div>
      </div>
    ))}
  </div>

  <div class="controls not-content">
    <p class="source-note">{sourceLabel}</p>
    <div class="actions">
      <button class="restart" type="button" data-race-restart>
        Restart
      </button>
      <button
        class="toggle-loop"
        type="button"
        data-race-infinite
        aria-pressed={infinite ? "true" : "false"}
      >
        {infinite ? "Infinite: on" : "Infinite: off"}
      </button>
    </div>
  </div>
</section>

<style>
  .bench{
    --fg: #1f2937;
    --muted: #4b5563;
    --line: rgba(15, 23, 42, 0.18);
    color: var(--fg);
    padding: 14px;
    border-radius: 14px;
    background: linear-gradient(
      180deg,
      rgba(255, 255, 255, 0.82),
      rgba(249, 250, 251, 0.72)
    );
    border: 1px solid rgba(15, 23, 42, 0.12);
    box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.5);
    overflow: hidden;
  }

  :global(:root[data-theme='dark']) .bench{
    --fg: rgba(241, 245, 249, 0.92);
    --muted: rgba(203, 213, 225, 0.72);
    --line: rgba(148, 163, 184, 0.24);
    background: linear-gradient(
      180deg,
      rgba(15, 23, 42, 0.62),
      rgba(15, 23, 42, 0.44)
    );
    border-color: rgba(148, 163, 184, 0.22);
    box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.06);
  }

  .legend{
    display:flex;
    gap:8px;
    flex-wrap:wrap;
    margin-bottom: 10px;
  }
  .pill{
    font-size: 12px;
    padding: 4px 8px;
    border-radius: 999px;
    border: 1px solid var(--line);
    color: var(--muted);
    background: rgba(255,255,255,0.28);
  }

  :global(:root[data-theme='dark']) .pill{
    background: rgba(15, 23, 42, 0.35);
  }

  .rows{
    display: grid;
    gap: var(--row-gap);
  }

  .controls{
    margin-top: 12px;
    display: flex;
    justify-content: space-between;
    align-items: center;
    gap: 8px;
  }

  .actions{
    display: flex;
    gap: 8px;
    align-items: center;
    margin-left: auto;
    flex: 0 0 auto;
  }

  .restart,
  .toggle-loop{
    border: 1px solid var(--line);
    border-radius: 8px;
    padding: 6px 10px;
    background: rgba(255,255,255,0.38);
    color: var(--fg);
    font-size: 12px;
    line-height: 1.2;
    cursor: pointer;
    display: inline-flex;
    align-items: center;
    justify-content: center;
    white-space: nowrap;
    min-height: 34px;
    touch-action: manipulation;
  }

  .restart:hover,
  .toggle-loop:hover{
    background: rgba(255,255,255,0.52);
  }

  :global(:root[data-theme='dark']) .restart,
  :global(:root[data-theme='dark']) .toggle-loop{
    background: rgba(15, 23, 42, 0.42);
  }

  :global(:root[data-theme='dark']) .restart:hover,
  :global(:root[data-theme='dark']) .toggle-loop:hover{
    background: rgba(30, 41, 59, 0.56);
  }

  .toggle-loop[aria-pressed='true']{
    background: rgba(16, 185, 129, 0.18);
    border-color: rgba(16, 185, 129, 0.45);
  }

  :global(:root[data-theme='dark']) .toggle-loop[aria-pressed='true']{
    background: rgba(16, 185, 129, 0.24);
    border-color: rgba(52, 211, 153, 0.52);
  }

  .source-note{
    margin: 0;
    text-align: left;
    color: var(--muted);
    font-size: 10px;
    line-height: 1.2;
    letter-spacing: 0.02em;
    text-transform: lowercase;
    flex: 1 1 auto;
    min-width: 0;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
  }

  .row{
    position: relative;
    display: grid;
    grid-template-columns: minmax(0, var(--label-w)) minmax(0, 1fr) minmax(9ch, max-content);
    align-items: center;

    min-height: var(--row-h);

    gap: 10px;
  }

  .label{
    font-size: 13px;
    color: var(--muted);
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
  }

  .meta{
    text-align: right;
    font-variant-numeric: tabular-nums;
    color: var(--muted);
    font-size: 11px;
    white-space: nowrap;
  }

  .track{
    position: relative;
    height: calc(var(--ball) + 8px);
    border-radius: 999px;
    /* Give the track its own box so 100% travel is predictable */
    width: 100%;
    contain: layout paint;
    display: flex;
    align-items: center;
    min-width: 0;
  }

  .bar{
    position: absolute;
    left: 0;
    top: 50%;
    width: var(--bar-w);
    height: clamp(8px, calc(var(--ball) * 0.42), 14px);
    transform: translateY(-50%);
    border-radius: 999px;
    background: color-mix(in oklab, var(--c) 52%, transparent);
    border: 1px solid color-mix(in oklab, var(--c) 78%, transparent);
    box-shadow: inset 0 0 0 1px rgba(255, 255, 255, 0.22);
    opacity: 0;
    pointer-events: none;
  }

  .ball{
    position:absolute;
    left: 0;
    top: 50%;
    width: var(--ball);
    height: var(--ball);
    transform: translate3d(0,-50%,0);
    border-radius: 999px;
    background: transparent;
    border: 2px solid var(--c);
    box-shadow:
      0 0 0 1px rgba(0,0,0,0.08),
      0 1px 4px rgba(0,0,0,0.14);

    /* Keep animation composited and avoid expensive filter effects. */
    backface-visibility: hidden;

    will-change: transform;

    /* Default travel, replaced by JS with exact pixels */
    --travel: calc(100% - var(--ball));

    animation: race calc(var(--dur) * 2) linear var(--delay) var(--iter) both;
    animation-play-state: paused;
  }

  .ball.is-finished{
    background: var(--c);
    box-shadow:
      0 0 0 1px rgba(0,0,0,0.08),
      0 1px 4px rgba(0,0,0,0.14),
      inset 0 0 0 1px rgba(255,255,255,0.35);
  }

  .bench.is-running .ball{
    animation-play-state: running;
  }

  .bench.is-bars .ball{
    animation: none;
    display: none;
  }

  .bench.is-bars .bar{
    opacity: 1;
  }

  .bench.is-bars .restart,
  .bench.is-bars .toggle-loop{
    display: none;
  }

  @keyframes race{
    from { transform: translate3d(0,-50%,0); }
    50% { transform: translate3d(var(--travel),-50%,0); }
    to { transform: translate3d(0,-50%,0); }
  }

  @media (max-width: 640px){
    .bench{
      padding: 12px;
    }

    .bench .ball{
      animation: none;
      display: none;
    }

    .bench .bar{
      opacity: 1;
    }

    .bench .restart,
    .bench .toggle-loop{
      display: none;
    }

    .row{
      grid-template-columns: minmax(0, 1fr) auto;
      grid-template-areas:
        "label meta"
        "track track";
      min-height: 0;
      gap: 6px 8px;
    }

    .label{
      grid-area: label;
      font-size: 12px;
    }

    .meta{
      grid-area: meta;
      font-size: 10px;
      max-width: 100%;
      white-space: normal;
      overflow-wrap: anywhere;
    }

    .track{
      grid-area: track;
    }

    .source-note{
      font-size: 10px;
    }
  }

  /* Respect reduced motion */
  @media (prefers-reduced-motion: reduce){
    .ball{
      animation: none;
      transform: translate3d(0, -50%, 0);
    }
  }
</style>

<script is:inline>
  // Initializes each BenchmarkBalls instance once.
  const sections = document.querySelectorAll(".bench[data-benchmark-balls]");
  const getConnectionInfo = () =>
    navigator.connection || navigator.mozConnection || navigator.webkitConnection || null;
  const shouldPreferBarsFallback = () => {
    const reducedMotion = window.matchMedia("(prefers-reduced-motion: reduce)").matches;
    if (reducedMotion) return true;

    const connection = getConnectionInfo();
    const effectiveType = String(connection?.effectiveType || "");
    if (connection?.saveData || /2g|slow-2g/i.test(effectiveType)) return true;

    const memory = typeof navigator.deviceMemory === "number" ? navigator.deviceMemory : null;
    const cores =
      typeof navigator.hardwareConcurrency === "number" ? navigator.hardwareConcurrency : null;

    return (memory !== null && memory <= 2) || (cores !== null && cores <= 2);
  };

  sections.forEach((section) => {
    if (!(section instanceof HTMLElement)) return;
    if (section.dataset.benchInit === "1") return;
    section.dataset.benchInit = "1";
    let isInfinite = section.dataset.benchInfinite === "1";
    let isBarsMode = false;

    const tracks = Array.from(section.querySelectorAll("[data-track]"));
    const balls = tracks.map((track) => track.querySelector(".ball"));
    const restart = section.querySelector("[data-race-restart]");
    const infiniteToggle = section.querySelector("[data-race-infinite]");
    const finishListeners = [];

    let stopTimer = 0;
    let noMotionTimer = 0;
    let ro = null;

    const parseCssTimeMs = (value) => {
      const str = String(value).trim();
      if (!str) return 0;
      if (str.endsWith("ms")) return Number.parseFloat(str) || 0;
      if (str.endsWith("s")) return (Number.parseFloat(str) || 0) * 1000;
      return Number.parseFloat(str) || 0;
    };

    const getRaceCycleMs = () => {
      let maxMs = 0;
      balls.forEach((ball) => {
        if (!(ball instanceof HTMLElement)) return;
        const styles = getComputedStyle(ball);
        const total = parseCssTimeMs(styles.animationDuration) + parseCssTimeMs(styles.animationDelay);
        maxMs = Math.max(maxMs, total);
      });
      return maxMs;
    };

    const readOffset = (ball, track) => {
      const ballRect = ball.getBoundingClientRect();
      const trackRect = track.getBoundingClientRect();
      return ballRect.left - trackRect.left;
    };

    const getReferencePair = () => {
      let reference = null;
      let referenceDuration = Number.POSITIVE_INFINITY;

      tracks.forEach((track, index) => {
        const ball = balls[index];
        if (!(track instanceof HTMLElement) || !(ball instanceof HTMLElement)) return;
        const styles = getComputedStyle(ball);
        const duration = parseCssTimeMs(styles.animationDuration);
        if (!duration) return;
        if (duration < referenceDuration) {
          referenceDuration = duration;
          reference = { track, ball };
        }
      });

      return reference;
    };

    const clearNoMotionWatchdog = () => {
      window.clearTimeout(noMotionTimer);
    };

    const removeFinishListeners = () => {
      while (finishListeners.length) {
        const entry = finishListeners.pop();
        if (!entry) break;
        const [ball, onFinish] = entry;
        ball.removeEventListener("animationend", onFinish);
      }
    };

    const updateTravel = () => {
      const raw = parseFloat(getComputedStyle(section).getPropertyValue("--ball"));
      const ballSize = Number.isFinite(raw) ? raw : 16;

      tracks.forEach((track, index) => {
        const ball = balls[index];
        if (!(track instanceof HTMLElement) || !(ball instanceof HTMLElement)) return;
        const fullTravel = Math.max(0, track.clientWidth - ballSize);
        ball.style.setProperty("--travel", `${fullTravel}px`);
      });
    };

    const onResize = () => updateTravel();

    const teardownMotionRuntime = () => {
      window.clearTimeout(stopTimer);
      clearNoMotionWatchdog();
      if (ro) {
        ro.disconnect();
        ro = null;
      }
      window.removeEventListener("resize", onResize);
      window.removeEventListener("orientationchange", onResize);
      removeFinishListeners();
    };

    const resetRace = () => {
      section.classList.remove("is-running");
      balls.forEach((ball) => {
        if (!(ball instanceof HTMLElement)) return;
        ball.classList.remove("is-finished");
        ball.style.animation = "none";
        // Force reflow so the next animation starts from 0.
        void ball.offsetHeight;
        ball.style.animation = "";
      });
    };

    const enableBarsMode = () => {
      if (isBarsMode) return;
      isBarsMode = true;
      section.dataset.benchMode = "bars";
      section.classList.add("is-bars");
      section.classList.remove("is-running");
      teardownMotionRuntime();
      if (restart instanceof HTMLButtonElement) restart.disabled = true;
      if (infiniteToggle instanceof HTMLButtonElement) infiniteToggle.disabled = true;
    };

    const scheduleNoMotionFallback = () => {
      clearNoMotionWatchdog();
      if (isBarsMode) return;
      const ref = getReferencePair();
      if (!ref) return;
      const startOffset = readOffset(ref.ball, ref.track);

      noMotionTimer = window.setTimeout(() => {
        if (isBarsMode) return;
        const endOffset = readOffset(ref.ball, ref.track);
        if (!Number.isFinite(startOffset) || !Number.isFinite(endOffset)) return;
        if (Math.abs(endOffset - startOffset) < 0.8) {
          enableBarsMode();
        }
      }, 1100);
    };

    const syncInfiniteUi = () => {
      section.dataset.benchInfinite = isInfinite ? "1" : "0";
      section.style.setProperty("--iter", isInfinite ? "infinite" : "1");
      if (infiniteToggle instanceof HTMLButtonElement) {
        infiniteToggle.setAttribute("aria-pressed", isInfinite ? "true" : "false");
        infiniteToggle.textContent = isInfinite ? "Infinite: on" : "Infinite: off";
      }
    };

    const startRace = () => {
      if (isBarsMode) return;
      const raceMs = isInfinite ? 0 : getRaceCycleMs();

      window.clearTimeout(stopTimer);
      clearNoMotionWatchdog();
      resetRace();

      requestAnimationFrame(() => {
        if (isBarsMode) return;
        section.classList.add("is-running");
        if (!isInfinite) {
          stopTimer = window.setTimeout(() => {
            section.classList.remove("is-running");
          }, raceMs || 1);
        }
        scheduleNoMotionFallback();
      });
    };

    const toggleInfinite = () => {
      if (isBarsMode) return;
      isInfinite = !isInfinite;
      syncInfiniteUi();
      startRace();
    };

    if ('ResizeObserver' in window) {
      ro = new ResizeObserver(updateTravel);
      ro.observe(section);
    } else {
      window.addEventListener('resize', onResize);
      window.addEventListener('orientationchange', onResize);
    }

    balls.forEach((ball) => {
      if (!(ball instanceof HTMLElement)) return;
      const onFinish = (event) => {
        if (!(event instanceof AnimationEvent)) return;
        if (event.animationName !== "race") return;
        ball.classList.add("is-finished");
      };
      ball.addEventListener("animationend", onFinish);
      finishListeners.push([ball, onFinish]);
    });

    if (restart instanceof HTMLButtonElement) {
      restart.addEventListener("click", startRace);
    }
    if (infiniteToggle instanceof HTMLButtonElement) {
      infiniteToggle.addEventListener("click", toggleInfinite);
    }

    syncInfiniteUi();
    updateTravel();
    if (shouldPreferBarsFallback()) {
      enableBarsMode();
    } else {
      startRace();
    }

    const cleanup = () => {
      teardownMotionRuntime();
      if (restart instanceof HTMLButtonElement) {
        restart.removeEventListener("click", startRace);
      }
      if (infiniteToggle instanceof HTMLButtonElement) {
        infiniteToggle.removeEventListener("click", toggleInfinite);
      }
    };

    window.addEventListener("pagehide", cleanup, { once: true });
    document.addEventListener("astro:before-swap", cleanup, { once: true });
  });
</script>
