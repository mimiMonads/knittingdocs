
<div class="ashes-container" data-ashes aria-hidden="true">
  <canvas data-ashes-buffer></canvas>
  <canvas data-ashes-main></canvas>
</div>

<script>
  const containers = document.querySelectorAll('[data-ashes]');
  const DEFAULT_PARTICLE_COUNT = 50;

  function getConnectionInfo() {
    return navigator.connection || navigator.mozConnection || navigator.webkitConnection || null;
  }

  function shouldDisableAshes() {
    const reducedMotion = window.matchMedia('(prefers-reduced-motion: reduce)').matches;
    if (reducedMotion) return true;

    const connection = getConnectionInfo();
    const effectiveType = String(connection?.effectiveType || '');
    if (connection?.saveData || /2g/i.test(effectiveType)) return true;

    const memory = typeof navigator.deviceMemory === 'number' ? navigator.deviceMemory : null;
    const cores =
      typeof navigator.hardwareConcurrency === 'number' ? navigator.hardwareConcurrency : null;

    return (memory !== null && memory <= 2) || (cores !== null && cores <= 2);
  }

  function getParticleCount(container) {
    if (shouldDisableAshes()) return 0;

    const area = Math.max(1, container.clientWidth * container.clientHeight);
    const areaScale = Math.min(1.25, Math.max(0.6, area / (1280 * 720)));
    let count = Math.round(DEFAULT_PARTICLE_COUNT * areaScale);

    const memory = typeof navigator.deviceMemory === 'number' ? navigator.deviceMemory : null;
    const cores =
      typeof navigator.hardwareConcurrency === 'number' ? navigator.hardwareConcurrency : null;

    if ((memory !== null && memory <= 4) || (cores !== null && cores <= 4)) {
      count = Math.min(count, 28);
    }

    return Math.max(0, count);
  }

  function normalizeHexColor(value) {
    if (!value) return null;
    const trimmed = value.trim();
    const match = trimmed.match(/^#([0-9a-f]{3}|[0-9a-f]{6})$/i);
    return match ? match[0] : null;
  }

  function hexToRgb() {
    const rootStyles = getComputedStyle(document.documentElement);
    const raw = rootStyles.getPropertyValue('--ashes');
    let hexColor = normalizeHexColor(raw);

    if (!hexColor) {
      hexColor = '#cfd3d7';
    }

    let hex = hexColor.replace(/^#/, '');
    if (hex.length === 3) {
      hex = [...hex].map((x) => x + x).join('');
    }

    const r = parseInt(hex.slice(0, 2), 16);
    const g = parseInt(hex.slice(2, 4), 16);
    const b = parseInt(hex.slice(4, 6), 16);

    return [r, g, b];
  }

  function startAshes(container) {
    const mainCanvas = container.querySelector('[data-ashes-main]');
    const bufferCanvas = container.querySelector('[data-ashes-buffer]');

    if (!(mainCanvas instanceof HTMLCanvasElement)) return () => {};
    if (!(bufferCanvas instanceof HTMLCanvasElement)) return () => {};

    const canvas = [mainCanvas, bufferCanvas];
    const ctxs = [canvas[0].getContext('2d'), canvas[1].getContext('2d')];

    if (!ctxs[0] || !ctxs[1]) return () => {};

    const particleCount = getParticleCount(container);
    if (particleCount <= 0) {
      container.dataset.ashesDisabled = '1';
      container.style.display = 'none';
      return () => {};
    }

    const incr = ((n) => () => (n < 0.7 ? (n = 0.00008 + n) : n))(0);
    let W = 0;
    let H = 0;
    let C = 0;
    let angle = 0;
    const A = [];

    function randomRange(from, to, seed) {
      return Math.floor((seed ? seed : Math.random()) * (to - from + 1) + from);
    }

    function Ash(o) {
      let i;
      let j;
      const m = Math.random();
      const p = randomRange(4, 8, m);
      const rgb = hexToRgb();

      if (o && o.x) this.x = o.x;
      else this.x = m * W;
      if (o && o.y) this.y = o.y;
      else this.y = m * H;
      if (o && o.a) this.a = o.a;
      else this.a = m * (p - 4) + 1;

      this.r = randomRange(rgb[0] - 10, rgb[0], m);
      this.g = randomRange(rgb[1] - 10, rgb[1], m);
      this.b = randomRange(rgb[2] - 10, rgb[2], m);

      if (o && o.dp) this.dp = o.dp;
      else {
        this.dp = [{ x: 0, y: 0 }];
        for (i = 0; i < p; i++) {
          j = i === 0 || p / 2 > i ? 1 : -1;
          this.dp.push({
            x: this.dp[i].x + randomRange(5, 30) * j,
            y: this.dp[i].y + randomRange(5, 30) * j,
          });
        }
      }
    }

    function resize() {
      W = container.offsetWidth;
      H = container.offsetHeight;
      canvas[0].width = W;
      canvas[0].height = H;
      canvas[1].width = W;
      canvas[1].height = H;
    }

    function draw() {
      let grad;
      let i;
      let j;
      let p;
      let ctx;

      if (C === 0) {
        canvas[0].style.visibility = 'visible';
        canvas[1].style.visibility = 'hidden';
        C = 1;
      } else {
        canvas[1].style.visibility = 'visible';
        canvas[0].style.visibility = 'hidden';
        C = 0;
      }

      ctx = ctxs[C];
      ctx.clearRect(0, 0, W, H);

      for (i = 0; i < A.length; i++) {
        p = A[i];
        grad = ctx.createRadialGradient(p.x, p.y, 0, p.x, p.y, p.a);
        grad.addColorStop(0, `rgba(${p.r}, ${p.g}, ${p.b}, 1)`);
        grad.addColorStop(0.9, `rgba(${p.r}, ${p.g}, ${p.b}, ${randomRange(1, 10) / 10})`);
        grad.addColorStop(1, `rgba(${p.r}, ${p.g}, ${p.b}, 0)`);

        ctx.beginPath();
        ctx.moveTo(p.x, p.y);
        for (j = 1; j < p.dp.length; j++) {
          ctx.lineTo(p.x + p.dp[j].x, p.y + p.dp[j].y);
        }
        ctx.closePath();
        ctx.fillStyle = grad;
        ctx.globalAlpha = incr();
        ctx.fill();
      }

      update();
    }

    function update() {
      let i;
      let p;
      angle += 0.01;

      for (i = 0; i < A.length; i++) {
        p = A[i];
        p.y += Math.cos(angle + A.length) + 1 + p.a / 2;
        p.x += Math.sin(angle) * 2;

        if (p.x > W + 5 || p.x < -5 || p.y > H) {
          if (i % 3 > 0) {
            A[i] = new Ash({ y: -10, a: p.a, d: p.d, dp: p.dp });
          } else {
            if (Math.sin(angle) > 0) {
              A[i] = new Ash({ x: -5, a: p.a, d: p.d, dp: p.dp });
            } else {
              A[i] = new Ash({ x: W + 5, a: p.a, d: p.d, dp: p.dp });
            }
          }
        }
      }
    }

    resize();
    for (let i = 0; i < particleCount; i++) A.push(new Ash());

    const intervalId = window.setInterval(draw, 33);
    const onResize = () => resize();

    window.addEventListener('resize', onResize);

    let resizeObserver;
    if ('ResizeObserver' in window) {
      resizeObserver = new ResizeObserver(() => resize());
      resizeObserver.observe(container);
    }

    return () => {
      window.clearInterval(intervalId);
      window.removeEventListener('resize', onResize);
      if (resizeObserver) resizeObserver.disconnect();
    };
  }

  const cleanups = [];
  containers.forEach((container) => {
    cleanups.push(startAshes(container));
  });

  const cleanupAll = () => {
    while (cleanups.length) {
      const fn = cleanups.pop();
      if (fn) fn();
    }
  };

  window.addEventListener('pagehide', cleanupAll, { once: true });
  document.addEventListener('astro:before-swap', cleanupAll, { once: true });
</script>

<style>
  :global(:root) {
    --ashes: #cfd3d7;
  }

  :global(:root[data-theme='dark']) {
    --ashes: #555a63;
  }

  .ashes-container {
    position: fixed;
    top: 0;
    left: 0;
    width: 100vw;
    height: 100vh;
    z-index: -1;
    pointer-events: none;
  }

  canvas {
    position: absolute;
    width: 100%;
    height: 100%;
    transform: translate3d(0, 0, 0);
  }
</style>
