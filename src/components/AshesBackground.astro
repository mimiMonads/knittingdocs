<div class="ashes-container" data-ashes aria-hidden="true">
  <canvas data-ashes-main></canvas>
</div>

<script>
  const containers = document.querySelectorAll('[data-ashes]');
  const CLEANUP_KEY = '__ashesCleanup';
  const BASE_PARTICLES = 58;
  const FRAME_MS = 1000 / 30;
  const MAX_DPR = 2;

  function normalizeHexColor(value) {
    if (!value) return null;
    const trimmed = value.trim();
    const match = trimmed.match(/^#([0-9a-f]{3}|[0-9a-f]{6})$/i);
    return match ? match[0] : null;
  }

  function clampColor(value) {
    return Math.max(0, Math.min(255, value));
  }

  function hexToRgb() {
    const rootStyles = getComputedStyle(document.documentElement);
    const raw = rootStyles.getPropertyValue('--ashes');
    let hexColor = normalizeHexColor(raw);

    if (!hexColor) hexColor = '#9aa1ab';

    let hex = hexColor.replace(/^#/, '');
    if (hex.length === 3) {
      hex = [...hex].map((x) => x + x).join('');
    }

    const r = parseInt(hex.slice(0, 2), 16);
    const g = parseInt(hex.slice(2, 4), 16);
    const b = parseInt(hex.slice(4, 6), 16);

    return [r, g, b];
  }

  function getParticleCount(width, height) {
    const area = Math.max(1, width * height);
    const areaScale = Math.min(1.25, Math.max(0.6, area / (1280 * 720)));
    let count = Math.round(BASE_PARTICLES * areaScale);

    const memory = typeof navigator.deviceMemory === 'number' ? navigator.deviceMemory : null;
    const cores =
      typeof navigator.hardwareConcurrency === 'number' ? navigator.hardwareConcurrency : null;

    if ((memory !== null && memory <= 4) || (cores !== null && cores <= 4)) {
      count = Math.min(count, 28);
    }

    return Math.max(0, count);
  }

  function startAshes(container) {
    const existingCleanup = container[CLEANUP_KEY];
    if (typeof existingCleanup === 'function') existingCleanup();

    const motionQuery = window.matchMedia('(prefers-reduced-motion: reduce)');
    if (motionQuery.matches) {
      container.style.display = 'none';
      return () => {};
    }

    const canvas = container.querySelector('[data-ashes-main]');
    if (!(canvas instanceof HTMLCanvasElement)) return () => {};

    const ctx = canvas.getContext('2d', { alpha: true });
    if (!ctx) return () => {};

    let W = 1;
    let H = 1;
    let dpr = 1;
    let angle = 0;
    let rgb = hexToRgb();
    const A = [];

    // Keep original fade-in behavior so particles do not pop all at once.
    const incr = ((n) => () => (n < 0.7 ? (n = 0.00008 + n) : n))(0);

    let rafId = 0;
    let lastTs = 0;

    function randomRange(from, to, seed) {
      return Math.floor((seed ? seed : Math.random()) * (to - from + 1) + from);
    }

    function recolorParticle(particle, seed) {
      const m = typeof seed === 'number' ? seed : Math.random();
      particle.r = clampColor(randomRange(rgb[0] - 10, rgb[0], m));
      particle.g = clampColor(randomRange(rgb[1] - 10, rgb[1], m));
      particle.b = clampColor(randomRange(rgb[2] - 10, rgb[2], m));
    }

    function Ash(o) {
      let i;
      let j;
      const m = Math.random();
      const p = randomRange(4, 8, m);

      if (o && typeof o.x === 'number') this.x = o.x;
      else this.x = m * W;
      if (o && typeof o.y === 'number') this.y = o.y;
      else this.y = m * H;
      if (o && typeof o.a === 'number') this.a = o.a;
      else this.a = m * (p - 4) + 1;

      recolorParticle(this, m);
      this.tailAlpha = randomRange(1, 10, m) / 10;

      if (o && o.dp) this.dp = o.dp;
      else {
        this.dp = [{ x: 0, y: 0 }];
        for (i = 0; i < p; i++) {
          j = i === 0 || p / 2 > i ? 1 : -1;
          this.dp.push({
            x: this.dp[i].x + randomRange(5, 30) * j,
            y: this.dp[i].y + randomRange(5, 30) * j,
          });
        }
      }
    }

    function syncParticleCount() {
      const target = getParticleCount(W, H);

      if (target > A.length) {
        const isInitialFill = A.length === 0;
        while (A.length < target) {
          A.push(isInitialFill ? new Ash() : new Ash({ y: -10 }));
        }
      } else if (target < A.length) {
        A.length = target;
      }
    }

    function resize() {
      const rect = container.getBoundingClientRect();
      W = Math.max(1, rect.width | 0);
      H = Math.max(1, rect.height | 0);

      dpr = Math.min(MAX_DPR, window.devicePixelRatio || 1);
      canvas.width = Math.round(W * dpr);
      canvas.height = Math.round(H * dpr);
      canvas.style.width = `${W}px`;
      canvas.style.height = `${H}px`;
      ctx.setTransform(dpr, 0, 0, dpr, 0, 0);

      syncParticleCount();
      if (A.length === 0) ctx.clearRect(0, 0, W, H);
    }

    function update() {
      angle += 0.01;
      const driftX = Math.sin(angle) * 2;
      const driftY = Math.cos(angle + A.length) + 1;

      for (let i = 0; i < A.length; i++) {
        const p = A[i];

        p.y += driftY + p.a / 2;
        p.x += driftX;

        if (p.x > W + 5 || p.x < -5 || p.y > H) {
          if (i % 3 > 0) {
            A[i] = new Ash({ y: -10, a: p.a, dp: p.dp });
          } else if (driftX > 0) {
            A[i] = new Ash({ x: -5, a: p.a, dp: p.dp });
          } else {
            A[i] = new Ash({ x: W + 5, a: p.a, dp: p.dp });
          }
        }
      }
    }

    function draw() {
      if (A.length === 0) return;

      ctx.clearRect(0, 0, W, H);

      for (let i = 0; i < A.length; i++) {
        const p = A[i];
        const grad = ctx.createRadialGradient(p.x, p.y, 0, p.x, p.y, p.a);
        grad.addColorStop(0, `rgba(${p.r}, ${p.g}, ${p.b}, 1)`);
        grad.addColorStop(0.9, `rgba(${p.r}, ${p.g}, ${p.b}, ${p.tailAlpha})`);
        grad.addColorStop(1, `rgba(${p.r}, ${p.g}, ${p.b}, 0)`);

        ctx.beginPath();
        ctx.moveTo(p.x, p.y);
        for (let j = 1; j < p.dp.length; j++) {
          ctx.lineTo(p.x + p.dp[j].x, p.y + p.dp[j].y);
        }
        ctx.closePath();
        ctx.fillStyle = grad;
        ctx.globalAlpha = incr();
        ctx.fill();
      }

      update();
      ctx.globalAlpha = 1;
    }

    function frame(ts) {
      if (lastTs === 0 || ts - lastTs >= FRAME_MS) {
        draw();
        lastTs = ts;
      }
      rafId = window.requestAnimationFrame(frame);
    }

    const onResize = () => resize();
    const onVisibility = () => {
      if (document.visibilityState === 'hidden') {
        lastTs = 0;
      }
    };
    const onThemeAttr = () => {
      // Apply new theme color only to newly spawned particles.
      rgb = hexToRgb();
    };

    const themeObserver = new MutationObserver(onThemeAttr);

    resize();
    rafId = window.requestAnimationFrame(frame);

    window.addEventListener('resize', onResize, { passive: true });
    document.addEventListener('visibilitychange', onVisibility);
    themeObserver.observe(document.documentElement, {
      attributes: true,
      attributeFilter: ['data-theme'],
    });

    const cleanup = () => {
      window.cancelAnimationFrame(rafId);
      window.removeEventListener('resize', onResize);
      document.removeEventListener('visibilitychange', onVisibility);
      themeObserver.disconnect();
      if (container[CLEANUP_KEY] === cleanup) {
        delete container[CLEANUP_KEY];
      }
    };

    container[CLEANUP_KEY] = cleanup;
    return cleanup;
  }

  const cleanups = [];
  containers.forEach((container) => {
    cleanups.push(startAshes(container));
  });

  const cleanupAll = () => {
    while (cleanups.length) {
      const fn = cleanups.pop();
      if (fn) fn();
    }
  };

  window.addEventListener('pagehide', cleanupAll, { once: true });
  document.addEventListener('astro:before-swap', cleanupAll, { once: true });
</script>

<style>
  :global(:root) {
    --ashes: #9aa1ab;
  }

  :global(:root[data-theme='dark']) {
    --ashes: #828891;
  }

  :global(:root[data-theme='light']) {
    --ashes: #ff9500;
  }

  .ashes-container {
    position: fixed;
    top: 0;
    left: 0;
    width: 100vw;
    height: 100vh;
    z-index: -1;
    pointer-events: none;
  }

  canvas {
    position: absolute;
    inset: 0;
    width: 100%;
    height: 100%;
    transform: translate3d(0, 0, 0);
  }
</style>
