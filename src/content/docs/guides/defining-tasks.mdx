---
title: Defining tasks
description: Wrap functions with task() and export them.
sidebar:
  order: 1
---

Task wraps a function so workers can discover and run
it. Tasks should be defined at module scope and exported.

```ts
type Task = {
  f: (uknown) => uknown,
  createPool?: (options: CreatePool) => SingleTaskPool,
  href?: string,
  timeout?: number | {
    time: number;
    maybe?: true;
    default?: unknown;
    error?: unknown;
  }
}

```

## Guidelines

- Define tasks at module scope (no conditional exports).
- Export tasks from the module where they are defined.
- Use a single argument; use a tuple or object for multiple values.
- Better to be on it's own file

### Simple task

Tasks are basically a fix point where the worker can import them with all the context of the file

```ts
import { task } from "@vixeny/knitting";

export const hello = task({
  f: async () => "hello",
});
```

### Task with arguments

Return type can be infer by used but the arguments has to be typed.

```ts
export const add = task({
  f: async ([a, b] : [number, number]) => a + b,
});
```

Or:

```ts
export const add = task<[number, number], number>({
  f: async ([a, b]) => a + b,
});
```

### Promise inputs and awaited outputs

Knitting accepts promise-like task inputs and always returns awaited task
results from `call.*()`.

#### What this means

- You can call `pool.call.someTask(Promise.resolve(value))`.
- If the input promise resolves, the resolved value is dispatched to the worker.
- If the input promise rejects, the host call rejects immediately and the task
  is not executed on the worker.
- If the task function returns a promise, Knitting awaits it before resolving or
  rejecting the host call.

#### Why this exists

Promises are runtime state, not transferable payload data.
Knitting resolves promise inputs on the host first, then serializes plain values
through IPC. This keeps transport deterministic while preserving ergonomic async
APIs.

#### Type guarantees

- Task inputs support `PromiseLike` values.
- Task handlers receive awaited input types (`Awaited<A>`).
- Task handlers can return `R` or `PromiseLike<R>`.
- `call.*()` returns `Promise<Awaited<R>>`, so callers receive the final
  resolved value type (not `Promise<Promise<...>>`).

```ts
type TaskInput<A> = A | PromiseLike<A>;
type TaskHandler<A, R> = (args: Awaited<A>) => R | PromiseLike<R>;
type CallResult<R> = Promise<Awaited<R>>;
```

#### Example

```ts
import { createPool, isMain, task } from "@vixeny/knitting";

export const addOne = task<Promise<number> | number, number>({
  f: (n) => {
    const next = n + 1; // n is already awaited here
    return Promise.resolve(next); // return can be a Promise
  },
});

const pool = createPool({ threads: 1 })({ addOne });

if (isMain) {
  // Promise input is accepted and resolved before dispatch.
  const result = await pool.call.addOne(Promise.resolve(41));
  console.log(result);
  // result: number (42), not Promise<number>
}
```

#### Behavior summary

| Case | Outcome |
| --- | --- |
| Promise argument fulfilled | Task runs with the fulfilled value. |
| Promise argument rejected | Host call rejects immediately and task is not run. |
| Async task result | Host call resolves/rejects with the awaited task outcome. |


## Optionals

You can easily modify the behaivour adding options to a task.

### `href` override behavior (unsafe / experimental)

By default, `task()` captures the caller module URL and workers use that for
task discovery.

Passing `href` overrides that module URL and forces workers to import from your
custom path/URL.

:::caution
`href` override is not considered a safe long-term public contract and may be
removed in a future major release.
:::

Rules for `href`:

- Prefer not using `href`; default caller resolution is the supported path.
- If you use it, pass an absolute module URL (`file://...` or full URL).
- Avoid remote URLs (`http(s)://...`) in production; runtime support and
  security expectations vary across Node, Deno, and Bun.
- Ensure the target module exports top-level `task(...)` values discoverable by
  workers.
- Ensure `href` points to a stable module identity (do not use ad-hoc dynamic
  URL variations for the same task module).
- Treat this as compatibility-risky and pin versions if you depend on it.

```ts
import { task } from "@vixeny/knitting";

const stableModuleHref = new URL("./tasks.ts", import.meta.url).href;

export const parseJob = task({
  href: stableModuleHref,
  f: (payload: string) => payload.length,
});
```

### Single-task pool

```ts
import { isMain, task } from "@vixeny/knitting";

export const world = task({
  f: async () => "world",
}).createPool({
  threads: 2,
});

if (isMain) {
  const results = await Promise.all([world.call()]);
  console.log("Results:", results);
  world.shutdown();
}
```

### Timeout

Supported forms:

- `number` (ms). Non-negative values reject with `Error("Task timeout")`.
- `{ time: number, default: value }` resolves with the provided value.
- `{ time: number, maybe: true }` resolves with `undefined`.
- `{ time: number, error: value }` rejects with the provided error.

If `time` is negative or missing, timeouts are ignored.
```ts
export const maybeSlow = task<string, string>({
  timeout: { time: 50, default: "timeout" },
  f: async (value) => value,
});
```


:::note

Timeouts race the task result; the underlying work may still complete even if
its promise resolves or rejects early.

:::
