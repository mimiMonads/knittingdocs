---
title: Big prime
description: "Prime Hunt in Big-Number Territory"
hero:
  title: 'Prime Hunt in Big-Number Territory'
sidebar:
  order: 1
banner:
  content: |
    This example could be improved with ` signals `
---

import { Tabs, TabItem } from '@astrojs/starlight/components';
import { Code } from '@astrojs/starlight/components';
import { getCode } from '../../../../lib/code-snippets';

export const run = getCode("maths/big_prime/run_prime.hunt.ts");
export const prime_scan = getCode("maths/big_prime/prime_scan.ts");

## What is this about

This example is a **parallel prime search** that scans through **large integers** (default: **1500-bit**) and tries to discover **probable primes** efficiently using Knitting.

Instead of “solving” something with exact math, we do what computers do best:

* test many candidates quickly,
* accept a **tiny probability of error**,
* scale out across threads.

This is a great teaching example because it combines:

* BigInt arithmetic
* probabilistic algorithms (Miller–Rabin)
* parallel batching and throughput

---

## What happens in this example

1. The host chooses a starting odd integer in the chosen bit-width (65-bit by default).
2. The host repeatedly scans **windows** of candidates.

   * Each window covers **10,000,000 odd candidates**.
   * After each window, it prints a progress line.
3. Each window is split across threads:

   * Threads scan disjoint candidate sequences (no overlap).
   * Work is further broken into chunk-sized tasks for smooth scheduling.
4. Each worker runs:

   * `candidate → Miller–Rabin → next candidate → ...`
5. If any worker finds a probable prime, it reports it for that window.
6. The process continues forever until the user stops it with **Ctrl+C**.

## Commands

:::info
Bun
```bash 
src/run_prime_hunt.ts --threads 4 --bits 1500 --total 10000000 --chunk 200000 --rounds 8
```
Deno
```bash
deno run -A src/run_prime_hunt.ts --threads 4 --bits 1500 --total 10000000 --chunk 200000 --rounds 8
```

Node
```bash
npx tsx  src/run_prime_hunt.ts --threads 4 --bits 1500 --total 10000000 --chunk 200000 --rounds 8
```
:::

## Code
<Tabs>
  <TabItem label="run.ts">
    <Code code={run} lang="ts" title={"run.ts"} />
  </TabItem>
    <TabItem label="prime_scan.ts">
    <Code code={prime_scan} lang="ts" title={"prime_scan.ts"} />
  </TabItem>
</Tabs>

## What is this good for

This is useful for students (and other AIs) to understand:

### Practical probabilistic computing

Prime testing at scale often uses probabilistic tests because they are extremely fast and reliable.

### Long-running compute pipelines

The “scan 10M, print progress, continue” structure is common in:

* large searches
* brute-force experiments
* sampling-based analysis
* monitoring throughput over time

### Parallel workload design

This shows how to parallelize work that is:

* independent per candidate
* CPU-heavy (BigInt exponentiation)
* naturally partitionable (disjoint strides)

---

## Scientific background

### Why primes are “findable”

Around a number size (N), the density of primes is roughly:
$$
\approx \frac{1}{\ln(N)}
$$
So primes get rarer as numbers get bigger, but not impossibly rare.

### Probable primes vs proven primes

This example finds **probable primes** using the **Miller–Rabin primality test**.

* **Probable prime**: passes a strong probabilistic test.
* **Proven prime**: guaranteed prime via deterministic proof methods.

In practice, with good parameters, Miller–Rabin has such a low false-positive rate that it’s widely used in cryptography and large integer libraries.

### Error probability intuition

Miller–Rabin can be tuned by increasing “rounds”.
More rounds means:

* higher confidence
* more compute per candidate

This example chooses a sensible default and lets you adjust with `--rounds`.

---

## How parallelization works here

### Disjoint scanning (no duplicated work)

Each thread scans candidates in an interleaved pattern:

* thread 0 checks: `start + 0`, `start + 2T`, `start + 4T`, ...
* thread 1 checks: `start + 2`, `start + 2 + 2T`, ...
* thread i checks: `start + 2i`, `start + 2i + 2T`, ...

(where (T =) number of threads)

This guarantees:

* no overlap across threads
* full coverage of the window
* even distribution of work



## Suggested exercises

1. Change `--bits` and observe how often primes appear.
2. Increase `--rounds` and measure throughput impact.
3. Compare different `--chunk` values and find a sweet spot.
4. Modify the task to search for:

   * twin primes (p and p+2)
   * Sophie Germain primes (p and 2p+1 prime)
   * safe primes (q prime and p=2q+1 prime)

