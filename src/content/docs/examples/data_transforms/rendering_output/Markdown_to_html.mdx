---
title: Markdown to HTML
description: Clean markdown-to-HTML example plus a separate mitata benchmark.
hero:
  title: 'Markdown rendering'
sidebar:
  order: 3
---

import { Tabs, TabItem } from '@astrojs/starlight/components';
import { Code } from '@astrojs/starlight/components';
import { getCode } from '../../../../../lib/code-snippets';

export const run = getCode("data_transforms/markdown_to_html/run_markdown_to_html.ts");
export const bench = getCode("data_transforms/markdown_to_html/bench_markdown_to_html.ts");
export const render_markdown = getCode("data_transforms/markdown_to_html/render_markdown.ts");

## What is this about

This page has two parts:

1. A clean example (`run_markdown_to_html.ts`) that focuses on usage and correctness.
2. A dedicated heavy benchmark (`bench_markdown_to_html.ts`) that uses `mitata` to compare host and worker throughput.

It complements React SSR as another **Rendering & Output** example.

## Install

:::info
Bun
```bash
bun add marked
bun add -d mitata
```
:::

`mitata` is only required for the benchmark script.

## Example command

:::info
Bun
```bash
bun src/run_markdown_to_html.ts --threads 2
```
Deno
```bash
deno run -A src/run_markdown_to_html.ts --threads 2
```

Node
```bash
npx tsx src/run_markdown_to_html.ts --threads 2
```
:::

## Benchmark command (mitata)

:::info
Bun
```bash
bun src/bench_markdown_to_html.ts --threads 2 --docs 2000
```
Node
```bash
npx tsx src/bench_markdown_to_html.ts --threads 2 --docs 2000
```
:::

## What happens in the example

1. Render one markdown document on the host.
2. Render the same markdown in a worker task.
3. Compare the HTML output from both paths.

## What the benchmark measures

- `host`: parse `N` markdown docs on the main thread.
- `knitting`: run `N` docs through a worker pool.
- Each document runs: parse markdown -> Brotli compress -> return raw compressed bytes.
- The benchmark validates host-vs-worker raw bytes before timing starts.

:::note
In this benchmark the limiting factor is often **moving bytes**, not CPU threads.
Both modes must allocate and touch the compressed output, and the worker mode also
has to transfer those bytes back to the host. Once byte movement dominates,
adding more threads stops helping (and can increase memory pressure).
:::

## Code

<Tabs>
  <TabItem label="run_markdown_to_html.ts">
    <Code code={run} lang="ts" title={"run_markdown_to_html.ts"} />
  </TabItem>
  <TabItem label="bench_markdown_to_html.ts">
    <Code code={bench} lang="ts" title={"bench_markdown_to_html.ts"} />
  </TabItem>
  <TabItem label="render_markdown.ts">
    <Code code={render_markdown} lang="ts" title={"render_markdown.ts"} />
  </TabItem>
</Tabs>

## Why this pattern matters

- The example stays easy to read and copy.
- Performance discussion moves to a heavier benchmark that prints real numbers.
- The benchmark path better reflects workloads where worker offload can pay off.
