---
title: Markdown to HTML
description: Markdown-to-HTML rendering with a simple host-vs-worker benchmark.
hero:
  title: 'Markdown rendering'
sidebar:
  order: 3
---

import { Tabs, TabItem } from '@astrojs/starlight/components';
import { Code } from '@astrojs/starlight/components';
import { getCode } from '../../../../../lib/code-snippets';

export const run = getCode("data_transforms/markdown_to_html/markdown_knitting.ts");
export const bench = getCode("data_transforms/markdown_to_html/bench_markdown_to_html.ts");
export const component = getCode("data_transforms/markdown_to_html/render_markdown.ts");

## What is this about

This example is split into three files:

1. `markdown_knitting.ts` runs markdown rendering in host and Knitting modes.
2. `render_markdown.ts` isolates the parser/render task.
3. `bench_markdown_to_html.ts` runs a quick benchmark with fixed settings (no flags).

It complements React SSR as another **Rendering & Output** example.

## Technologies used (and why)

- **`marked`**: practical markdown parser for realistic transform workloads.
- **Knitting tasks**: compares direct host calls and worker task execution for the same renderer.
- **Brotli (`node:zlib`)**: benchmark path includes compression so byte movement cost is visible.

## Install

:::info
Bun
```bash
bun add marked
```
:::

## Run

:::info
Bun
```bash
bun src/markdown_knitting.ts
```
Deno
```bash
deno run -A src/markdown_knitting.ts
```

Node
```bash
npx tsx src/markdown_knitting.ts
```
:::

## Quick bench

:::info
Bun
```bash
bun src/bench_markdown_to_html.ts
```
Node
```bash
npx tsx src/bench_markdown_to_html.ts
```
:::

## What happens in the example

1. Render one markdown document on the host.
2. Render the same markdown in a worker task.
3. Compare the HTML output from both paths.

## What the benchmark measures

- `host`: parse + compress `N` markdown docs via direct imports.
- `knitting`: run the same `N` docs through worker tasks.
- Benchmark validates host-vs-worker raw bytes before reporting throughput.

:::note
This benchmark includes both execution paths in one script, so the main variable
is host import vs worker task path.
:::

## Code

<Tabs>
  <TabItem label="markdown_knitting.ts">
    <Code code={run} lang="ts" title={"markdown_knitting.ts"} />
  </TabItem>
  <TabItem label="bench_markdown_to_html.ts">
    <Code code={bench} lang="ts" title={"bench_markdown_to_html.ts"} />
  </TabItem>
  <TabItem label="render_markdown.ts">
    <Code code={component} lang="ts" title={"render_markdown.ts"} />
  </TabItem>
</Tabs>

## Why this pattern matters

- It isolates rendering logic from orchestration and benchmarking.
- It keeps benchmark commands simple and reproducible.
- It compares host imports and task execution with one workload shape.
