---
title: Markdown to HTML
description: Markdown-to-HTML rendering with a simple host-vs-worker benchmark.
hero:
  title: 'Markdown rendering'
sidebar:
  order: 3
---

import { Tabs, TabItem } from '@astrojs/starlight/components';
import { Code } from '@astrojs/starlight/components';
import { getCode } from '../../../../../lib/code-snippets';
import LibraryInstallTabs from '../../../../../components/LibraryInstallTabs.astro';
import RuntimeRunTabs from '../../../../../components/RuntimeRunTabs.astro';

export const bench = getCode("data_transforms/markdown_to_html/bench_markdown_to_html.ts");
export const component = getCode("data_transforms/markdown_to_html/render_markdown.ts");

## What is this about

This example focuses on two files:

1. `bench_markdown_to_html.ts` runs a host-vs-worker `mitata` benchmark.
2. `render_markdown.ts` isolates markdown rendering and compression tasks.

Shared markdown builders and byte helpers live in `utils.ts` so benchmark code stays focused.

## Technologies used (and why)

- **`marked`**: practical markdown parser for realistic transform workloads.
- **Knitting tasks**: compares direct host calls and worker task execution for the same renderer.
- **Brotli (`node:zlib`)**: benchmark path includes compression so byte movement cost is visible.
- **`mitata`**: provides a standard benchmark harness for host vs worker runs.

## Install

:::info
<LibraryInstallTabs
  jsrPackages={["@vixeny/knitting"]}
  npmPackages={["marked", "mitata"]}
  denoUseNpmInterop={true}
/>
:::

## Quick bench

:::info
<RuntimeRunTabs
  bunCommand="bun src/bench_markdown_to_html.ts"
  denoCommand="deno run -A src/bench_markdown_to_html.ts"
/>
:::

## What happens in the example

1. The host generates markdown documents.
2. The host path parses markdown, renders HTML, then compresses with Brotli.
3. The worker path runs the same compression task via `markdownToHtmlCompressed`.
4. Host and worker compressed-byte totals are compared for parity.
5. `mitata` reports timing and relative speed for host and worker runs.

## What the benchmark measures

- `host`: parse + render + Brotli compress via direct imports.
- `knitting`: the same document set through compression task calls.
- Byte parity is checked before benchmark sampling starts.

## Code

<Tabs>
  <TabItem label="bench_markdown_to_html.ts">
    <Code code={bench} lang="ts" title={"bench_markdown_to_html.ts"} />
  </TabItem>
  <TabItem label="render_markdown.ts">
    <Code code={component} lang="ts" title={"render_markdown.ts"} />
  </TabItem>
</Tabs>

## Why this pattern matters

- It isolates markdown transform logic from benchmark orchestration.
- It centralizes repetitive markdown builders and byte helpers in `utils.ts`.
- It keeps benchmark commands simple and reproducible.
- It compares host imports and task execution with one workload shape.
