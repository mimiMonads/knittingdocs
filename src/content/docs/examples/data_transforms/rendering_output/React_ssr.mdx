---
title: React SSR
description: "Parse payloads and render HTML in worker threads"
hero:
  title: 'React SSR'
sidebar:
  order: 1

---

import { Tabs, TabItem } from '@astrojs/starlight/components';
import { Code } from '@astrojs/starlight/components';
import { getCode } from '../../../../../lib/code-snippets';
import DontDoubleParseTip from '../../../../../components/tips/DontDoubleParseTip.astro';
import WorkRightFastTip from '../../../../../components/tips/WorkRightFastTip.astro';

export const run = getCode("data_transforms/react_ssr/run_ssr.ts");
export const render_user_card = getCode("data_transforms/react_ssr/render_user_card.tsx");

## What is this about

Most data-transform pipelines follow the same shape: parse input, validate it,
then produce output.

This example uses a realistic web path:

1. The host receives user payloads (simulated with JSON strings).
2. A worker parses and validates the payload.
3. The worker renders an HTML string using **React SSR** (`renderToString`).
4. The host sends the HTML to the client (or caches it, compresses it, etc.).

To keep the comparison fair, payloads are intentionally tiny (&lt;= 44 bytes of
JSON). That makes transfer overhead visible.

This is a practical starting point for workloads like:

* parsing lots of JSON
* validating inputs
* generating HTML
* keeping your main thread responsive while CPU work happens elsewhere

---

## Install

:::info
Bun
```bash
bun add react react-dom
```
:::

This page uses Bun for simplicity, but the same architecture works in Node and
Deno: `parse -> validate -> render`, then compare worker mode against host-only.

## What happens in this example

1. The host creates a pool with `createPool({ threads })`.
2. The host queues jobs with `call.*()`.
3. Each worker runs:
   * `JSON.parse(payload)`
   * basic validation / defaults
   * HTML rendering via `react-dom/server`
4. Workers run `renderUserCardHost` and return `{ html, bytes }`.
5. The host aggregates stats and prints throughput.

<DontDoubleParseTip />

## Commands

:::info
Bun
```bash
src/run_ssr.ts --threads 1 --requests 50000 --batch 64 \
--mode knitting
```
Host baseline (no workers)
```bash
src/run_ssr.ts --requests 50000 --batch 64 --mode host
```
:::

## Code
<Tabs>
  <TabItem label="run_ssr.ts">
    <Code code={run} lang="ts" title={"run_ssr.ts"} />
  </TabItem>
  <TabItem label="render_user_card.tsx">
    <Code code={render_user_card} lang="tsx" title={"render_user_card.tsx"} />
  </TabItem>
</Tabs>

---

## Why this is a good “data transform” example

This pattern generalizes well:

* **Parsing**: JSON, CSV, logs, protobuf, HTML, markdown…
* **Validation**: type checks, ranges, defaults, schema enforcement
* **Transformation**: normalize fields, enrich data, extract features, build tokens…
* **Rendering / output**: HTML strings, token arrays, compressed buffers, indexes...


## Practical notes

### Keep return values small

`renderUserCardHost` returns `{ html, bytes }` for convenience.
In fast loops, extra allocations add up, so keep return payloads small and avoid
work you do not need.

In this example the object is small, so readability wins. Optimize only after
you measure.

<WorkRightFastTip />

### Keep worker payloads simple

Send primitives and plain objects/arrays. In SSR workflows, send:

* the parsed data needed to render
* a template key / component id
* maybe a small set of feature flags

Don’t try to send live framework objects (React elements, class instances, DB connections).

### JSX / TSX support

The worker uses **TSX** so it can render a real React component. Bun supports `.tsx` directly. (Node and Deno can do the same, but the setup differs.)

### React SSR note

This example uses `renderToString` from `react-dom/server` to keep the output a plain string. For streaming SSR in Bun, the Bun guide uses `renderToReadableStream`.

### Treat HTML like untrusted output until you escape it

If you render from user-provided fields, escape or sanitize them. Avoid `dangerouslySetInnerHTML` unless you fully control the input.
