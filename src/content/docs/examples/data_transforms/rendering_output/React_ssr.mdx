---
title: React SSR
description: A practical React SSR example with a clear host-vs-worker benchmark.
hero:
  title: 'React SSR'
sidebar:
  order: 1

---

import { Tabs, TabItem } from '@astrojs/starlight/components';
import { Code } from '@astrojs/starlight/components';
import { getCode } from '../../../../../lib/code-snippets';
import DontDoubleParseTip from '../../../../../components/tips/DontDoubleParseTip.astro';

export const run = getCode("data_transforms/react_ssr/run_ssr.ts");
export const render_user_card = getCode("data_transforms/react_ssr/render_user_card.tsx");

## What is this about

This page has two parts:

1. A practical SSR example (`run_ssr.ts`) that keeps the pipeline simple: parse -> validate -> render.
2. A side-by-side benchmark using the same script in `--mode knitting` and `--mode host`.

## Install

:::info
Bun
```bash
bun add react react-dom
```
:::

This page uses Bun for simplicity, but the same setup also works in Node and
Deno.

## Example command

Run this first to confirm the example is working end-to-end.

:::info
Bun
```bash
bun src/run_ssr.ts --threads 2 --requests 1000 --mode knitting
```
Deno
```bash
deno run -A src/run_ssr.ts --threads 2 --requests 1000 --mode knitting
```
Node
```bash
npx tsx src/run_ssr.ts --threads 2 --requests 1000 --mode knitting
```
:::

## Benchmark commands

Then run both modes with the same request count and compare throughput.

:::info
Bun
```bash
bun src/run_ssr.ts --threads 2 --requests 50000 --mode knitting
```
Host baseline (no workers)
```bash
bun src/run_ssr.ts --requests 50000 --mode host
```
Deno
```bash
deno run -A src/run_ssr.ts --threads 2 --requests 50000 --mode knitting
```
Host baseline (no workers)
```bash
deno run -A src/run_ssr.ts --requests 50000 --mode host
```
Node
```bash
npx tsx src/run_ssr.ts --threads 2 --requests 50000 --mode knitting
```
Host baseline (no workers)
```bash
npx tsx src/run_ssr.ts --requests 50000 --mode host
```
:::

## What happens in the example

1. The host generates JSON payload strings.
2. In `--mode knitting`, the host sends each payload to `renderUserCard`.
3. The task parses JSON, applies defaults, and renders HTML with React SSR.
4. In `--mode host`, the same work runs on the main thread.
5. The runner prints throughput so the two modes are easy to compare.

## What the benchmark measures

- `host`: parse + validate + render `N` requests on the main thread.
- `knitting`: run the same `N` requests through worker threads.
- Payloads are intentionally small, so transfer overhead is still visible.
- The output shape is `{ html, bytes }`, which keeps aggregation straightforward.

<DontDoubleParseTip />

## Code
<Tabs>
  <TabItem label="run_ssr.ts">
    <Code code={run} lang="ts" title={"run_ssr.ts"} />
  </TabItem>
  <TabItem label="render_user_card.tsx">
    <Code code={render_user_card} lang="tsx" title={"render_user_card.tsx"} />
  </TabItem>
</Tabs>

## Why this pattern matters

- It shows a realistic parse/validate/render flow.
- It keeps host and worker paths directly comparable with one runner script.
- It is a solid baseline before adding compression, caching, or streaming output.
