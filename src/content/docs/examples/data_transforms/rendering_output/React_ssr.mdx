---
title: React SSR
description: A practical React SSR example with a simple host-vs-worker benchmark.
hero:
  title: 'React SSR'
sidebar:
  order: 1

---

import { Tabs, TabItem } from '@astrojs/starlight/components';
import { Code } from '@astrojs/starlight/components';
import { getCode } from '../../../../../lib/code-snippets';
import DontDoubleParseTip from '../../../../../components/tips/DontDoubleParseTip.astro';
import LibraryInstallTabs from '../../../../../components/LibraryInstallTabs.astro';
import RuntimeRunTabs from '../../../../../components/RuntimeRunTabs.astro';

export const bench = getCode("data_transforms/react_ssr/bench_react_ssr.ts");
export const component = getCode("data_transforms/react_ssr/render_user_card.tsx");

## What is this about

This example is split into three files:

1. `react_ssr_knitting.ts` runs parse + SSR in host and Knitting modes.
2. `render_user_card.tsx` isolates the SSR component and task.
3. `bench_react_ssr.ts` runs a quick `mitata` benchmark with fixed settings (no flags).

## Technologies used (and why)

- **React SSR (`renderToString`)**: models a realistic server render workload.
- **Knitting tasks**: compares direct host function calls and worker task calls with the same renderer.
- **JSON payload strings**: keeps parse + normalize cost visible, not just render cost.
- **`mitata`**: provides a standard benchmark harness for host vs worker runs.

## Install

:::info
<LibraryInstallTabs
  jsrPackages={["@vixeny/knitting"]}
  npmPackages={["react", "react-dom", "mitata"]}
  denoUseNpmInterop={true}
/>
:::

This page uses Bun for simplicity, but the same setup also works in Node and
Deno.

## Deno setup (TSX + npm)

If you run this directly with Deno and see:

```txt
Uncaught SyntaxError: Unexpected token '<'
```

set a root `deno.json` so Deno transpiles TSX and resolves npm packages from
`node_modules`:

```json
{
  "nodeModulesDir": "auto",
  "compilerOptions": {
    "jsx": "react-jsx",
    "jsxImportSource": "react"
  }
}
```

This repo already includes that config, so `deno run -A ...` works without extra flags.


## Quick bench

:::info
<RuntimeRunTabs
  bunCommand="bun src/bench_react_ssr.ts"
  denoCommand="deno run -A src/bench_react_ssr.ts"
  nodeCommand="npx tsx src/bench_react_ssr.ts"
/>
:::

## What happens in the example

1. The host generates JSON payload strings.
2. `renderUserCardHost` executes directly on the host and returns an HTML string.
3. `renderUserCard` executes the same logic through worker tasks.
4. Runners compute byte counts from `html.length`, and parity is validated before benchmarking.
5. `mitata` reports timing and relative speed for host and worker runs.

## What the benchmark measures

- `host`: parse + normalize + render using direct imports (host returns HTML string).
- `knitting`: the same payload set through task calls in a worker pool.
- Byte parity is checked once before benchmark sampling starts.

<DontDoubleParseTip />

## Code
<Tabs>

  <TabItem label="bench_react_ssr.ts">
    <Code code={bench} lang="ts" title={"bench_react_ssr.ts"} />
  </TabItem>
  <TabItem label="render_user_card.tsx">
    <Code code={component} lang="tsx" title={"render_user_card.tsx"} />
  </TabItem>
</Tabs>

## Why this pattern matters

- It isolates component logic from orchestration and benchmarking.
- It keeps benchmark commands simple and reproducible.
- It compares host imports and task execution with one workload shape.
