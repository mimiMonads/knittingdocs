---
title: React SSR
description: A practical React SSR example with a simple host-vs-worker benchmark.
hero:
  title: 'React SSR'
sidebar:
  order: 1

---

import { Tabs, TabItem } from '@astrojs/starlight/components';
import { Code } from '@astrojs/starlight/components';
import { getCode } from '../../../../../lib/code-snippets';
import DontDoubleParseTip from '../../../../../components/tips/DontDoubleParseTip.astro';

export const run = getCode("data_transforms/react_ssr/react_ssr_knitting.ts");
export const bench = getCode("data_transforms/react_ssr/bench_react_ssr.ts");
export const component = getCode("data_transforms/react_ssr/render_user_card.tsx");

## What is this about

This example is split into three files:

1. `react_ssr_knitting.ts` runs parse + SSR in host and Knitting modes.
2. `render_user_card.tsx` isolates the SSR component and task.
3. `bench_react_ssr.ts` runs a quick benchmark with fixed settings (no flags).

## Technologies used (and why)

- **React SSR (`renderToString`)**: models a realistic server render workload.
- **Knitting tasks**: compares direct host function calls and worker task calls with the same renderer.
- **JSON payload strings**: keeps parse + normalize cost visible, not just render cost.

## Install

:::info
Bun
```bash
bun add react react-dom
```
:::

This page uses Bun for simplicity, but the same setup also works in Node and
Deno.

## Run

:::info
Bun
```bash
bun src/react_ssr_knitting.ts
```
Deno
```bash
deno run -A src/react_ssr_knitting.ts
```
Node
```bash
npx tsx src/react_ssr_knitting.ts
```
:::

## Quick bench

:::info
Bun
```bash
bun src/bench_react_ssr.ts
```
Deno
```bash
deno run -A src/bench_react_ssr.ts
```
Node
```bash
npx tsx src/bench_react_ssr.ts
```
:::

## What happens in the example

1. The host generates JSON payload strings.
2. `renderUserCardHost` executes directly on the host for baseline numbers.
3. `renderUserCard` executes the same logic through worker tasks.
4. Both paths produce byte counts from rendered HTML.
5. The benchmark prints host throughput, worker throughput, and uplift.

## What the benchmark measures

- `host`: parse + normalize + render using direct imports.
- `knitting`: the same payload set through task calls in a worker pool.
- Byte parity is reported so output equivalence stays visible.

<DontDoubleParseTip />

## Code
<Tabs>
  <TabItem label="react_ssr_knitting.ts">
    <Code code={run} lang="ts" title={"react_ssr_knitting.ts"} />
  </TabItem>
  <TabItem label="bench_react_ssr.ts">
    <Code code={bench} lang="ts" title={"bench_react_ssr.ts"} />
  </TabItem>
  <TabItem label="render_user_card.tsx">
    <Code code={component} lang="tsx" title={"render_user_card.tsx"} />
  </TabItem>
</Tabs>

## Why this pattern matters

- It isolates component logic from orchestration and benchmarking.
- It keeps benchmark commands simple and reproducible.
- It compares host imports and task execution with one workload shape.
