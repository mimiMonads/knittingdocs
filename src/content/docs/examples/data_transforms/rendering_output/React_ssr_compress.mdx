---
title: React SSR compression
description: A practical SSR+compression example with a simple host-vs-worker benchmark.
hero:
  title: 'SSR + compression'
sidebar:
  order: 2

---

import { Tabs, TabItem } from '@astrojs/starlight/components';
import { Code } from '@astrojs/starlight/components';
import { getCode } from '../../../../../lib/code-snippets';
import DontDoubleParseTip from '../../../../../components/tips/DontDoubleParseTip.astro';
import LibraryInstallTabs from '../../../../../components/LibraryInstallTabs.astro';
import RuntimeRunTabs from '../../../../../components/RuntimeRunTabs.astro';

export const bench = getCode("data_transforms/react_ssr_compress/bench_react_ssr_compress.ts");
export const component = getCode("data_transforms/react_ssr_compress/render_user_card_compressed.tsx");
export const utils = getCode("data_transforms/react_ssr_compress/utils.ts");


## What is this about

This example focuses on two files:

1. `bench_react_ssr_compress.ts` runs a host-vs-worker `mitata` benchmark with fixed settings.
2. `render_user_card_compressed.tsx` isolates the compression task.

Shared payload/compression helpers live in `utils.ts` so benchmark and task files stay focused.

## Technologies used (and why)

- **React SSR (`renderToString`)**: generates real HTML workload before compression.
- **Brotli (`node:zlib`)**: models CPU-heavy response compression on the server path.
- **Knitting tasks**: compares direct host compression and worker task compression.
- **JSON payload strings**: keeps parse + normalize cost visible, not just compression cost.
- **`mitata`**: provides a standard benchmark harness for host vs worker runs.

## Install

:::info
<LibraryInstallTabs
  jsrPackages={["@vixeny/knitting"]}
  npmPackages={["react", "react-dom", "mitata"]}
  denoUseNpmInterop={true}
/>
:::

Compression uses the built-in `node:zlib` APIs (no extra packages required).

## Quick bench

:::info
<RuntimeRunTabs
  bunCommand="bun src/bench_react_ssr_compress.ts"
  denoCommand="deno run -A src/bench_react_ssr_compress.ts"
/>
:::

## What happens in this example

1. The host generates JSON payload strings.
2. The host path renders HTML and compresses with Brotli.
3. The worker path runs the same compression logic via `renderUserCardCompressed`.
4. Host and worker compressed-byte totals are compared for parity.
5. `mitata` reports timing and relative speed for host and worker runs.

## What the benchmark measures

- `host`: parse + SSR + Brotli compress via direct imports.
- `knitting`: the same payload set through compression task calls.
- Byte parity is reported to verify output consistency.

<DontDoubleParseTip />


## Code

<Tabs>
  <TabItem label="render_user_card_compressed.tsx">
    <Code code={component} lang="tsx" title={"render_user_card_compressed.tsx"} />
  </TabItem>
  <TabItem label="bench_react_ssr_compress.ts">
    <Code code={bench} lang="ts" title={"bench_react_ssr_compress.ts"} />
  </TabItem>
    <TabItem label="utils.ts">
    <Code code={utils} lang="tsx" title={"utils.ts"} />
  </TabItem>
</Tabs>



## Why this pattern matters

- It isolates card-compression logic from benchmark orchestration.
- It centralizes repetitive payload/compression helpers in `utils.ts`.
- It keeps benchmark commands simple and reproducible.
- It compares host imports and task execution with one workload shape.
