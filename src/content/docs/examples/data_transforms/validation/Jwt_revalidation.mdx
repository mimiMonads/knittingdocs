---
title: JWT revalidation
description: Validate JWTs, renew when policy allows, and benchmark host vs worker throughput.
hero:
  title: 'JWT validation + renewal'
sidebar:
  order: 2
---

import { Tabs, TabItem } from '@astrojs/starlight/components';
import { Code } from '@astrojs/starlight/components';
import { getCode } from '../../../../../lib/code-snippets';

export const run = getCode("data_transforms/jwt_revalidation/run_jwt_revalidation.ts");
export const bench = getCode("data_transforms/jwt_revalidation/bench_jwt_revalidation.ts");
export const jwt_revalidation = getCode("data_transforms/jwt_revalidation/jwt_revalidation.ts");

## What is this about

This page has two parts:

1. A practical JWT example (`run_jwt_revalidation.ts`) that verifies tokens and renews them when policy allows.
2. A dedicated benchmark (`bench_jwt_revalidation.ts`) that measures host vs worker throughput with `mitata`.

## Install

:::info
Bun
```bash
bun add -d mitata
```
:::

This example uses built-in Web Crypto APIs (`HMAC SHA-256`) and does not need a separate JWT package.
`mitata` is only required for the benchmark script.

## Example command

:::info
Bun
```bash
bun src/run_jwt_revalidation.ts --threads 2 --requests 25000 --invalid 10 --mode knitting
```
Deno
```bash
deno run -A src/run_jwt_revalidation.ts --threads 2 --requests 25000 --invalid 10 --mode knitting
```
Node
```bash
npx tsx src/run_jwt_revalidation.ts --threads 2 --requests 25000 --invalid 10 --mode knitting
```
:::

## Benchmark command (mitata)

:::info
Bun
```bash
bun src/bench_jwt_revalidation.ts --threads 2 --requests 50000 --invalid 10 --batch 64
```
Node
```bash
npx tsx src/bench_jwt_revalidation.ts --threads 2 --requests 50000 --invalid 10 --batch 64
```
:::

## What happens in this example

1. The host builds request payloads containing JWT strings.
2. Each task validates token format, header, claims, and HMAC signature.
3. It checks renewal policy (`renewWindowSec` + `renewUntil` hard cutoff).
4. If renewable, it creates a new JWT; otherwise it keeps or rejects the token.
5. The task stringifies the response and sends it back.

## What the benchmark measures

- `host`: verify + optional renewal + `JSON.stringify` on `N` requests.
- `knitting`: the same `N` requests through worker threads.
- Requests are sent in batches (`--batch`) to amortize per-call dispatch overhead.
- Each batch returns compact counters and output byte totals.

:::note
JWT workloads often mix CPU and transport cost. Signature checks are CPU work,
while returning many JSON strings adds transfer overhead. Batch size can change
which side dominates.
:::

## Code

<Tabs>
  <TabItem label="run_jwt_revalidation.ts">
    <Code code={run} lang="ts" title={"run_jwt_revalidation.ts"} />
  </TabItem>
  <TabItem label="bench_jwt_revalidation.ts">
    <Code code={bench} lang="ts" title={"bench_jwt_revalidation.ts"} />
  </TabItem>
  <TabItem label="jwt_revalidation.ts">
    <Code code={jwt_revalidation} lang="ts" title={"jwt_revalidation.ts"} />
  </TabItem>
</Tabs>

## Why this pattern matters

- It keeps token validation and renewal logic deterministic.
- It shows when token rotation can run on workers vs main thread.
- It keeps a benchmark path that includes real response serialization work.
