---
title: Schema validate
description: Clean Zod validation example with a simple host-vs-worker benchmark.
hero:
  title: 'Validation + parsing'
sidebar:
  order: 1
---

import { Tabs, TabItem } from '@astrojs/starlight/components';
import { Code } from '@astrojs/starlight/components';
import { getCode } from '../../../../../lib/code-snippets';
import LibraryInstallTabs from '../../../../../components/LibraryInstallTabs.astro';
import RuntimeRunTabs from '../../../../../components/RuntimeRunTabs.astro';

export const run = getCode("data_transforms/schema_validate/schema_knitting.ts");
export const bench = getCode("data_transforms/schema_validate/bench_schema_validate.ts");
export const utils = getCode("data_transforms/schema_validate/utils.ts");

## What is this about

This example is split into three files:

1. `schema_knitting.ts` runs parse+validate in host and Knitting modes.
2. `utils.ts` isolates schema logic, payload builders, and task exports.
3. `bench_schema_validate.ts` runs a host-vs-worker benchmark with `mitata`.

## Technologies used (and why)

- **Zod**: schema-first validation with typed outputs and predictable error paths.
- **Knitting tasks**: compares direct host imports and worker task execution for the same validator.
- **Batched payloads**: benchmark path batches JSON strings so dispatch overhead is controlled.
- **`mitata`**: provides a standard benchmark harness for host vs worker runs.

## Install

:::info
<LibraryInstallTabs
  jsrPackages={["@vixeny/knitting"]}
  npmPackages={["zod", "mitata"]}
  denoUseNpmInterop={true}
/>
:::

## Run

:::info
<RuntimeRunTabs
  bunCommand="bun src/schema_knitting.ts"
  denoCommand="deno run -A src/schema_knitting.ts"
  nodeCommand="npx tsx src/schema_knitting.ts"
/>
:::

## Quick bench

:::info
<RuntimeRunTabs
  bunCommand="bun src/bench_schema_validate.ts"
  nodeCommand="npx tsx src/bench_schema_validate.ts"
/>
:::

## What happens in this example

1. The host generates JSON strings (some valid, some intentionally invalid).
2. Each job parses the string.
3. Zod validates the parsed object against `UserSchema`.
4. The task returns `{ ok: true, value }` or `{ ok: false, issues }`.
5. The host aggregates valid/invalid counts and prints sample issues.

## What the benchmark measures

- `host`: `JSON.parse + UserSchema.safeParse` via direct function imports.
- `knitting`: the same payload batches through worker task calls.
- Batch calls keep per-dispatch overhead predictable.

:::note
This benchmark includes both execution paths in one script, so the main variable is
host import vs worker task path.
:::

## Code

<Tabs>
  <TabItem label="schema_knitting.ts">
    <Code code={run} lang="ts" title={"schema_knitting.ts"} />
  </TabItem>
  <TabItem label="bench_schema_validate.ts">
    <Code code={bench} lang="ts" title={"bench_schema_validate.ts"} />
  </TabItem>
  <TabItem label="utils.ts">
    <Code code={utils} lang="ts" title={"utils.ts"} />
  </TabItem>
</Tabs>

## Why this pattern matters

- It isolates schema logic and payload builders in one reusable utility module.
- It keeps benchmark commands simple and reproducible.
- It compares host imports and task execution with one workload shape.
