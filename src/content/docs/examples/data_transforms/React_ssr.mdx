---
title: React SSR 
description: "Parse payloads and render HTML in worker threads"
hero:
  title: 'React SSR'
sidebar:
  order: 1
  
---

import { Tabs, TabItem } from '@astrojs/starlight/components';
import { Code } from '@astrojs/starlight/components';
import { getCode } from '../../../../lib/code-snippets';
import DontDoubleParseTip from '../../../../components/tips/DontDoubleParseTip.astro';
import WorkRightFastTip from '../../../../components/tips/WorkRightFastTip.astro';

export const run = getCode("data_transforms/react_ssr/run_ssr.ts");
export const render_user_card = getCode("data_transforms/react_ssr/render_user_card.tsx");

## What is this about

“Data transforms” usually means: take some input bytes, **parse** them, **validate** them, then **turn them into something else**.

This example does exactly that, but with a realistic web flavor:

1. The host receives user payloads (we simulate this with JSON strings).
2. A worker parses + validates the payload.
3. The worker renders an HTML string using **React SSR** (`renderToString`).
4. The host sends the HTML to the client (or caches it, compresses it, etc.).

To make the comparison fair, the simulated request payloads are **tiny** (≤ **44 bytes** of JSON). That keeps the “send the work” overhead honest.

It’s not “scientific”, it’s just a clean way to learn the Knitting workflow for workloads like:

* parsing lots of JSON
* validating inputs
* generating HTML
* keeping your main thread responsive while CPU work happens elsewhere

---

## Install

:::info
Bun
```bash
bun add react react-dom
```
:::

This page uses Bun for the commands because it runs TypeScript/TSX with very little ceremony. The same architecture works in Node and Deno too — it’s still just “parse → validate → render”, then compare worker mode vs host-only.

## What happens in this example

1. The host creates a pool with `createPool({ threads })`.
2. The host queues jobs with `call.*()`.
3. Each worker runs:
   * `JSON.parse(payload)`
   * basic validation / defaults
   * HTML rendering via `react-dom/server`
5. Workers runs `renderUserCardHost` return `{ html, bytes }`.
6. The host aggregates stats and prints throughput.

<DontDoubleParseTip />

## Commands

:::info
Bun
```bash
src/run_ssr.ts --threads 1 --requests 50000 --batch 64 \
--mode knitting
```
Host baseline (no workers)
```bash
src/run_ssr.ts --requests 50000 --batch 64 --mode host
```
:::

## Code
<Tabs>
  <TabItem label="run_ssr.ts">
    <Code code={run} lang="ts" title={"run_ssr.ts"} />
  </TabItem>
  <TabItem label="render_user_card.tsx">
    <Code code={render_user_card} lang="tsx" title={"render_user_card.tsx"} />
  </TabItem>
</Tabs>

---

## Why this is a good “data transform” example

This pattern generalizes nicely:

* **Parsing**: JSON, CSV, logs, protobuf, HTML, markdown…
* **Validation**: type checks, ranges, defaults, schema enforcement
* **Transformation**: normalize fields, enrich data, extract features, build tokens…
* **Rendering / output**: HTML strings, token arrays, compressed buffers, indexes…


## Practical notes

## What was the fastest way do do it?

As you saw `renderUserCardHost` return `{ html, bytes }` , this means :

  - Two extra object creations and one Stringication.

Now, this is nor a big issue because the object in question was small, 
don't try to get optimal optimizations until you get something workings.

<WorkRightFastTip />

### Keep worker payloads simple

Send primitives and plain objects/arrays. In SSR workflows, send:

* the parsed data needed to render
* a template key / component id
* maybe a small set of feature flags

Don’t try to send live framework objects (React elements, class instances, DB connections).

### JSX / TSX support

The worker uses **TSX** so it can render a real React component. Bun supports `.tsx` directly. (Node and Deno can do the same, but the setup differs.)

### React SSR note

This example uses `renderToString` from `react-dom/server` to keep the output a plain string. For streaming SSR in Bun, the Bun guide uses `renderToReadableStream`.

### Treat HTML like untrusted output until you escape it

If you render from user-provided fields, escape or sanitize them. Avoid `dangerouslySetInnerHTML` unless you fully control the input.
